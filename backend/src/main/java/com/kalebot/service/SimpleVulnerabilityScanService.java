package com.kalebot.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.kalebot.core.VulnerabilityScanService;
import com.kalebot.model.vuln.Dependency;
import com.kalebot.model.vuln.Finding;
import com.kalebot.model.vuln.Reference;
import com.kalebot.model.vuln.ScanReport;
import com.kalebot.model.vuln.Severity;
import com.kalebot.model.vuln.Source;
import com.kalebot.model.vuln.Vulnerability;
import com.kalebot.vuln.GradleDependencyParser;
import com.kalebot.vuln.MavenPomParser;
import com.kalebot.vuln.NvdClient;
import com.kalebot.vuln.OsvClient;
import com.kalebot.vuln.OsvClient.DependencyCoordinate;
import com.kalebot.vuln.OsvClient.OsvBatchResult;
import com.kalebot.vuln.OsvClient.OsvVulnerability;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Service
public class SimpleVulnerabilityScanService implements VulnerabilityScanService {
  private final JdbcTemplate jdbcTemplate;
  private final ObjectMapper objectMapper;
  private final OsvClient osvClient;
  private final NvdClient nvdClient;
  private final MavenPomParser mavenPomParser = new MavenPomParser();
  private final GradleDependencyParser gradleDependencyParser = new GradleDependencyParser();

  public SimpleVulnerabilityScanService(
      JdbcTemplate jdbcTemplate,
      ObjectMapper objectMapper,
      OsvClient osvClient,
      NvdClient nvdClient
  ) {
    this.jdbcTemplate = jdbcTemplate;
    this.objectMapper = objectMapper;
    this.osvClient = osvClient;
    this.nvdClient = nvdClient;
  }

  @Override
  public Mono<ScanReport> scan(String inputType, String content) {
    String normalized = normalize(content);
    String inputHash = hashInput(inputType, normalized);
    return loadCached(inputHash)
        .switchIfEmpty(Mono.defer(() -> performScan(inputType, normalized)
            .flatMap(report -> saveScan(inputHash, inputType, report).thenReturn(report))));
  }

  private Mono<ScanReport> loadCached(String hash) {
    return Mono.fromCallable(() -> jdbcTemplate.query(
        "SELECT result_jsonb FROM dependency_scans WHERE input_hash = ?",
        (rs, rowNum) -> rs.getString("result_jsonb"),
        hash
    ))
        .subscribeOn(Schedulers.boundedElastic())
        .flatMap(rows -> {
          if (rows.isEmpty()) {
            return Mono.empty();
          }
          try {
            return Mono.just(objectMapper.readValue(rows.get(0), ScanReport.class));
          } catch (Exception e) {
            return Mono.empty();
          }
        });
  }

  private Mono<Void> saveScan(String hash, String inputType, ScanReport report) {
    return Mono.fromRunnable(() -> {
      try {
        jdbcTemplate.update(
            "INSERT INTO dependency_scans (scan_id, input_hash, input_type, created_at, result_jsonb) "
                + "VALUES (?, ?, ?, ?, ?) ON CONFLICT (input_hash) DO NOTHING",
            java.util.UUID.randomUUID(),
            hash,
            inputType,
            OffsetDateTime.now(),
            objectMapper.writeValueAsString(report)
        );
      } catch (Exception ignored) {
        // Best-effort cache.
      }
    }).subscribeOn(Schedulers.boundedElastic()).then();
  }

  private Mono<ScanReport> performScan(String inputType, String content) {
    List<Dependency> dependencies = parseDependencies(inputType, content);
    if (dependencies.isEmpty()) {
      return Mono.just(new ScanReport(List.of(), List.of(), List.of()));
    }

    List<Dependency> dependenciesWithVersion = dependencies.stream()
        .filter(dep -> dep.version() != null && !dep.version().isBlank())
        .toList();
    List<DependencyCoordinate> coords = DependencyCoordinate.from(dependenciesWithVersion);
    return osvClient.queryBatch(coords)
        .flatMap(results -> buildFindings(dependencies, dependenciesWithVersion, results))
        .map(findings -> {
          List<Source> sources = collectSources(findings);
          return new ScanReport(dependencies, findings, sources);
        });
  }

  private Mono<List<Finding>> buildFindings(
      List<Dependency> dependencies,
      List<Dependency> dependenciesWithVersion,
      List<OsvBatchResult> results
  ) {
    Map<String, List<String>> idsByDependency = new LinkedHashMap<>();
    for (int i = 0; i < dependenciesWithVersion.size(); i++) {
      Dependency dependency = dependenciesWithVersion.get(i);
      List<String> ids = i < results.size()
          ? Optional.ofNullable(results.get(i).ids()).orElseGet(List::of)
          : List.of();
      idsByDependency.put(dependency.group() + ":" + dependency.artifact() + ":" + dependency.version(), ids);
    }

    return Flux.range(0, dependencies.size())
        .flatMap(index -> {
          Dependency dependency = dependencies.get(index);
          List<String> ids = idsByDependency.getOrDefault(
              dependency.group() + ":" + dependency.artifact() + ":" + dependency.version(),
              List.of()
          );
          if (ids.isEmpty()) {
            return Mono.just(new Finding(dependency, List.of()));
          }
          return osvClient.fetchVulnerabilities(ids)
              .flatMap(vulns -> enrichWithNvd(vulns))
              .map(vulnerabilities -> new Finding(dependency, vulnerabilities));
        })
        .filter(finding -> !finding.vulnerabilities().isEmpty())
        .collectList();
  }

  private Mono<List<Vulnerability>> enrichWithNvd(List<OsvVulnerability> vulnerabilities) {
    return Flux.fromIterable(vulnerabilities)
        .flatMap(vuln -> {
          String cve = vuln.aliases().stream()
              .filter(alias -> alias.startsWith("CVE-"))
              .findFirst()
              .orElse(null);
          if (cve == null) {
            return Mono.just(toVulnerability(vuln, vuln.severity()));
          }
          return nvdClient.fetchSeverity(cve)
              .map(severity -> toVulnerability(vuln, severity))
              .switchIfEmpty(Mono.just(toVulnerability(vuln, vuln.severity())));
        }, 2)
        .collectList();
  }

  private Vulnerability toVulnerability(OsvVulnerability vuln, Severity severity) {
    return new Vulnerability(
        vuln.id(),
        vuln.aliases(),
        vuln.summary(),
        vuln.details(),
        severity,
        vuln.references()
    );
  }

  private List<Source> collectSources(List<Finding> findings) {
    Map<String, Source> sources = new LinkedHashMap<>();
    for (Finding finding : findings) {
      for (Vulnerability vuln : finding.vulnerabilities()) {
        String osvUrl = "https://osv.dev/vulnerability/" + vuln.osvId();
        sources.putIfAbsent(osvUrl, new Source("OSV " + vuln.osvId(), osvUrl, "osv"));
        for (String alias : vuln.aliases()) {
          if (alias.startsWith("CVE-")) {
            String nvdUrl = "https://nvd.nist.gov/vuln/detail/" + alias;
            sources.putIfAbsent(nvdUrl, new Source("NVD " + alias, nvdUrl, "nvd"));
          }
        }
        for (Reference reference : vuln.references()) {
          if (reference.url() != null && !reference.url().isBlank()) {
            sources.putIfAbsent(reference.url(), new Source(reference.type(), reference.url(), "advisory"));
          }
        }
      }
    }
    return new ArrayList<>(sources.values());
  }

  private List<Dependency> parseDependencies(String inputType, String content) {
    if ("maven_pom".equalsIgnoreCase(inputType)) {
      return mavenPomParser.parse(content);
    }
    if ("gradle".equalsIgnoreCase(inputType)) {
      return gradleDependencyParser.parse(content);
    }
    if ("coordinates".equalsIgnoreCase(inputType)) {
      return parseCoordinates(content);
    }
    throw new IllegalArgumentException("Unsupported input type: " + inputType);
  }

  private List<Dependency> parseCoordinates(String content) {
    if (content == null || content.isBlank()) {
      return List.of();
    }
    List<Dependency> dependencies = new ArrayList<>();
    String[] lines = content.split("\\r?\\n");
    for (String line : lines) {
      String trimmed = line.trim();
      if (trimmed.isEmpty()) {
        continue;
      }
      String[] parts = trimmed.split(":");
      if (parts.length < 3) {
        continue;
      }
      String group = parts[0];
      String artifact = parts[1];
      String version = parts[2];
      dependencies.add(new Dependency(group, artifact, version, buildPurl(group, artifact, version)));
    }
    return dependencies;
  }

  private String normalize(String content) {
    if (content == null) {
      return "";
    }
    return content.trim().replace("\r\n", "\n").replace("\r", "\n");
  }

  private String hashInput(String inputType, String content) {
    try {
      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      String combined = inputType + "::" + content;
      byte[] hash = digest.digest(combined.getBytes(StandardCharsets.UTF_8));
      StringBuilder builder = new StringBuilder();
      for (byte b : hash) {
        builder.append(String.format("%02x", b));
      }
      return builder.toString();
    } catch (Exception e) {
      throw new IllegalStateException("Failed to hash input", e);
    }
  }

  private String buildPurl(String groupId, String artifactId, String version) {
    if (version == null || version.isBlank()) {
      return "pkg:maven/" + groupId + "/" + artifactId;
    }
    return "pkg:maven/" + groupId + "/" + artifactId + "@" + version;
  }
}
